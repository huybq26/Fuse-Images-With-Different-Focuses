# -*- coding: utf-8 -*-
"""DepthMap.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16rlOub_ufZBCPcg5XpIEVfM66bxQsSKu
"""



# !python3 main.py -i /content/image-background-remove-tool/ROI_199_199.png -o ./ -prep bbd-fastrcnn -postp rtb-bnb -m basnet

import numpy as np
import cv2
import subprocess
import os
import tifffile
from PIL import Image
import matplotlib.pyplot as plt
import shutil
import torch
import os
from skimage import io
from nets.sesf_net import SESF_Fuse
import glob
import cv2
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-s", "--sample", type=str)

args = parser.parse_args()
sample = args.sample

################################### Fusing multi-focus ###################################
sesf = SESF_Fuse("cse")

#os.chdir('/Users/dbenet/Desktop/PhD/Chapter2_automatic_class/capytol2/deepL/scan_im2images/image-background-remove-tool/')
# Two images of same size 

path_to_dependency = "/home/damia001/ash_dataset/dependencies/depthmap"

pathDir = os.getcwd() #Current working directory at SESF-Fuse

if not os.path.exists(f'{pathDir}/samples/{sample}'):
     os.makedirs(f'{pathDir}/samples/{sample}')
image_path = os.path.join(pathDir, f'samples/{sample}')

def fuse_images(images, width, height, scale_percent): #width = 2736, height = 1824):
  while len(images) >=2:

    num_pair = len(images)//2
    imgs = []
    #width2 = 2736
    #height2 = 1824

    for i in range(num_pair):
      img1 = images[2*i]
      img2 = images[2*i + 1]

      print(f'the original dimensions of image1 are: {img1.shape}')
      print(f'the original dimensions of image2 are: {img2.shape}')

      print(f'the width and height are {width} and {height}')

      # img1 = cv2.resize(img1, (width2, height2), interpolation=cv2.INTER_AREA)
      # img2 = cv2.resize(img2, (width2, height2), interpolation=cv2.INTER_AREA)
 
      new_width = int(width * scale_percent / 100)
      new_height = int(height * scale_percent / 100)
      dim = (new_width, new_height)
  
      img1 = cv2.resize(img1, dim, interpolation = cv2.INTER_AREA)
      img2 = cv2.resize(img2, dim, interpolation = cv2.INTER_AREA)
 

      print(f'the dimensions of image1 are: {img1.shape}')
      print(f'the dimensions of image2 are: {img2.shape}')

      print(f'Fusing images {2*i} and {2*i + 1}')
      img = sesf.fuse(img1, img2)
      imgs.append(img)
      torch.cuda.empty_cache()

    images = imgs
    print(f'Fused image dimensions are: {len(images[0])}')
    
  return images[0]

def main_process_new(nrow = 10, ncol = 10) -> None:
  images = []
  list_files = os.listdir(image_path)
  num = 0
  for name in list_files:
    if 'TileScan_001_Merging' in name: num += 1
  for i in range(num):
    if i < 10:
      images.append(io.imread(os.path.join(image_path, 'TileScan_001_Merging--Z0{}.tif'.format(i))))
    else:
      images.append(io.imread(os.path.join(image_path, 'TileScan_001_Merging--Z{}.tif'.format(str(i)))))

  max_width, max_height = images[0].shape[1], images[0].shape[0]
  pattern_width = max_width // nrow
  pattern_height = max_height // ncol 
  
  final_image = None
  cnt = 0
  for r in range(nrow):
    cur_row = None
    y = r * pattern_height
    y1 = y + pattern_height
    if y == nrow - 1: y1 = max_height 
    
    for c in range(ncol):
      x = c * pattern_width
      x1 = x + pattern_width
      if c == ncol - 1: x1 = max_width 

      patterns = []
      for img in images:
        patterns.append(img[y: y1, x: x1]) # y: y1: y, y+1, ... y1-1

      after_fused = fuse_images(patterns, pattern_width, pattern_height, 60)
      if cur_row is None: cur_row = after_fused
      else: cur_row = cv2.hconcat([cur_row, after_fused])    
    
    print("Done row: " + str(cnt))
    io.imsave("cur_row_{}.tif".format(cnt), cur_row)
    cnt += 1
    if final_image is None: final_image = cur_row
    else: final_image = cv2.vconcat([final_image, cur_row])
  io.imsave(os.path.join(image_path, "sesf-final.tif"), final_image)

main_process_new(10, 10)

################################### Contours detection ###################################
def fillContour(imageName) -> None:
  img = cv2.imread(imageName)

  (width, height) = Image.open(imageName).size
  empty = np.zeros([width, height, 3],dtype=np.uint8)

  imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

  ret,thresh = cv2.threshold(imgray, 0, 255, 0)
  contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)

  index = 1
  thickness = 1
  color = (255, 255, 255)

  mask = np.ones(imgray.shape)
  mask = cv2.drawContours(mask, contours, -1, (255, 255, 255), -1)

  cv2.imwrite(imageName, mask)

def process(pixel_size: int, step: int) -> None:
  image_in = tifffile.imread(os.path.join(image_path, "sesf-final.tif"))

  (h, w, _) = image_in.shape
  res_image = np.ones([h,w,3], dtype="uint8") * 125
  cv2.imwrite(os.path.join(image_path,'initRes.jpg'), res_image)
  # print(h, w)
  print("Image shape: ", image_in.shape)

  for i in range(0, h, step):
    for j in range(0, w, step):
      h_loop = pixel_size if (i+pixel_size<=h) else  h-i
      w_loop = pixel_size if (j+pixel_size<=w) else  w-j
      tmp_image = np.ones([h_loop, w_loop, 3], dtype="uint8") * 255
      
      tmp_image[0:h_loop,0:w_loop] = image_in[i:i+h_loop, j:j+w_loop]

      imgName = 'ROI_{}_{}_{}.png'.format(step, i+h_loop-1, j+w_loop-1)
      image_path_tmp = os.path.join(image_path, imgName)
      left_image = tmp_image
      cv2.imwrite(image_path_tmp, tmp_image[...,::-1])
      
      command = "cd {} && python3 {} -i {} -o {} -prep bbd-fastrcnn -postp rtb-bnb -m basnet".format(path_to_dependency, "main.py", image_path_tmp, image_path_tmp)
      os.system(command)
      fillContour(image_path_tmp)

      tmp_img = cv2.imread(image_path_tmp)
      right_image = tmp_img[...,::-1]

      save_image = np.hstack((left_image, right_image))
      cv2.imwrite(image_path_tmp, save_image)
      print(tmp_img.shape)
      for r in range(h_loop):
        for c in range(w_loop):
          if list(res_image[i+r, j+c])[0]<=125:
            res_image[i+r, j+c] = tmp_img[r, c]

  cv2.imwrite(os.path.join(image_path, 'finalMask.tif'), res_image)
  h,w,_ = res_image.shape
  dim = (int(w/20),int(h/20))
  resized_depthmap = cv2.resize(res_image, dim, interpolation = cv2.INTER_AREA)
  resized_scanimage = cv2.resize(image_in,dim, interpolation = cv2.INTER_AREA)
  cv2.imwrite(os.path.join(image_path, "thumbnail_finalMask.tif"), resized_depthmap)
  cv2.imwrite(os.path.join(image_path, "thumbnail_scanimage.tif"), resized_scanimage[...,::-1]) # as it was read from tifffile

if 'phi2phi3' in image_path:
  process(1000, 125)

elif 'phi1phi2' in image_path:
  process(3500, 500)

elif 'phi0phi1' in image_path:
  process(6000, 1000)

elif 'morephi0' in image_path:
  process(7000, 2000)

################################### Segment and Archive ###################################
# File managements
parentFolder = image_path # abs path
nameFolder  = os.path.basename(parentFolder)
volcanoName = nameFolder.split('-')[0]
afeName = nameFolder.split('_')[0]

# public_folder = "damia001"

if not os.path.exists(f'/home/damia001/volcash/{volcanoName}'):
  os.mkdir(f'/home/damia001/volcash/{volcanoName}') 

if not os.path.exists(f'/home/damia001/volcash/{volcanoName}/{afeName}'):
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}')
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles')
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/alpha')
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/normalized')
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/black_background')
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/center_background')
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/original')

if not os.path.exists(f'/home/damia001/volcash/{volcanoName}/{afeName}/{nameFolder}'):
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}/{nameFolder}')  
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}/{nameFolder}/original') 
  os.mkdir(f'/home/damia001/volcash/{volcanoName}/{afeName}/{nameFolder}/thumbnails')

dstThumbnails = f'/home/damia001/volcash/{volcanoName}/{afeName}/{nameFolder}/thumbnails'
srcThumbnails = glob.glob(f'{image_path}/thumbnail*.tif')

for src in srcThumbnails:
  shutil.copy(src, dstThumbnails)

dst = f'/home/damia001/volcash/{volcanoName}/{afeName}/{nameFolder}/original'

srcOriginal = os.path.join(image_path, "sesf-final.tif")
srcDepthmap = os.path.join(image_path, "finalMask.tif")

shutil.copy(srcOriginal, dst)
shutil.copy(srcDepthmap, dst)

def process_segmentation(depthmapName, scanimageName, center):
  ''''''
  folderName = image_path # ! this will produce an error
  # if os.path.exists(f'{folderName}/{center}results/'):
  #   shutil.rmtree(f'{folderName}/{center}results/')
  # os.makedirs(f'{folderName}/{center}results/')

  depthmapPath = os.path.join(folderName, depthmapName)
  depthmap = tifffile.imread(depthmapPath)
  depthmap = cv2.cvtColor(depthmap, cv2.COLOR_BGR2GRAY)

  ret, thresh_depthmap = cv2.threshold(depthmap, 120, 255, cv2.THRESH_BINARY)
  contoursPrelim, hier = cv2.findContours(thresh_depthmap, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
  print(len(contoursPrelim))

  contours = [contour for contour in contoursPrelim if len(contour) > 500]
  scanimage = tifffile.imread(scanimageName)

  for idx, contour in enumerate(contours):
    i = idx + 1

    ext_left = tuple(contour[contour[:, :, 0].argmin()][0])
    ext_right = tuple(contour[contour[:, :, 0].argmax()][0])
    ext_top = tuple(contour[contour[:, :, 1].argmin()][0])
    ext_bot = tuple(contour[contour[:, :, 1].argmax()][0])

    margin = int((ext_bot[1] - ext_top[1])/6)

    croppedScanimage = scanimage[ext_top[1]-margin:ext_bot[1]+margin, ext_left[0]-margin:ext_right[0]+margin]
    
    try:
      # Write to SESF-Fuse folder
      tmp_img_path_tif = os.path.join(folderName, f"{idx}_{nameFolder}_temp.tif")
      tmp_img_path_png = os.path.join(folderName, f"{idx}_{nameFolder}_temp.png")

      cv2.imwrite(tmp_img_path_tif, croppedScanimage[...,::-1]) # as tifffile does rgb, but opencv bgr
      # Write to 
      cv2.imwrite(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/original/{nameFolder}_{i}_original.tif', croppedScanimage[...,::-1])
      command1 = f"cd {path_to_dependency} && python3 main.py -i {tmp_img_path_tif} -o {tmp_img_path_png} -prep bbd-fastrcnn -postp rtb-bnb -m basnet"
      os.system(command1)
    except:
      pass

    if os.path.exists(tmp_img_path_png):
      im4ch = cv2.imread(tmp_img_path_png, cv2.IMREAD_UNCHANGED)
      alpha_channel = im4ch[...,-1]

      imageOriginal = cv2.imread(tmp_img_path_tif)

      ret, thr = cv2.threshold(alpha_channel, 120, 255, cv2.THRESH_BINARY)
      contours, hier = cv2.findContours(thr, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

      print(len(contours))
    
      rob_mask = np.ones(imageOriginal.shape) * 255
      rob_mask = cv2.drawContours(rob_mask, contours, -1,(0,0,0), -1)
      rob_masked = imageOriginal.copy()
      rob_masked[np.logical_not(rob_mask)] = 0

      #cv2.imwrite(f'{folderName}/{idx}background.jpg', rob_masked)

      rob_red = rob_masked[...,2].flatten()
      red_mean = rob_red[rob_red > 70].mean()
      rob_green = rob_masked[...,1]
      green_mean = rob_green[rob_green > 70].mean()
      rob_blue = rob_masked[...,0]
      blue_mean = rob_blue[rob_blue > 70].mean()

      red, green, blue = cv2.split(imageOriginal)

      norm_red = red * (center/red_mean)
      norm_red = norm_red.astype(int)
      #uint_red[uint_red > 255] = 255

      norm_green = green * (center/green_mean)
      norm_green = norm_green.astype(int)
      #uint_green[uint_green > 255] = 255

      norm_blue = blue * (center/blue_mean)
      norm_blue = norm_blue.astype(int)
      #uint_blue[uint_blue > 255] = 255

      im_normalized = np.dstack((norm_red,norm_green,norm_blue))
      cv2.imwrite(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/normalized/{nameFolder}_{i}_normalized.jpg', im_normalized)

      part_mask = np.zeros(imageOriginal.shape)
      part_mask = cv2.drawContours(part_mask, contours, -1,(255,255,255), -1)     
      black_masked = im_normalized.copy()
      center_masked = im_normalized.copy()

      black_masked[np.logical_not(part_mask)] = 0
      cv2.imwrite(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/black_background/{nameFolder}_{i}_blackbackground.png', black_masked)

      center_masked[np.logical_not(part_mask)] = center
      cv2.imwrite(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/center_background/{nameFolder}_{i}_centerbackground.png', center_masked)

      im_normalized = cv2.imread(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/normalized/{nameFolder}_{i}_normalized.jpg')
      red, green, blue = cv2.split(im_normalized)
      alpha_channel = alpha_channel.astype(np.uint8)
      im_alpha = cv2.merge((red, green, blue, alpha_channel))
      cv2.imwrite(f'/home/damia001/volcash/{volcanoName}/{afeName}/particles/alpha/{nameFolder}_{i}_alpha.png', im_alpha)

process_segmentation('finalMask.tif',f'{parentFolder}/sesf-final.tif', 200)











































